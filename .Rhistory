fit
summary(fit)
summary(fit.real)
summary(fit)
summary(fit)==summarise(fit.real)
summary(fit)==summary(fit.real)
fit$coefficients ==fit.real$coefficients
fit$coefficients ==fit.real$coefficients
aic(fit)
#check
fit$coefficients ==fit.real$coefficients
fit$aic == fit.real$aic
fit$residuals == fit.real$residuals
##use query to create data####
# NOT YET DONE #
endpoint <- "http://localhost:3030/dataA2/query"
get.data <- function(){
sparql <- "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
Prefix : <http://www.semanticweb.org/trans_experiment#>
Prefix om: <http://www.ontology-of-units-of-measure.org/resource/om-2/>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX tr: <http://www.thomsonreuters.com/>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
SELECT ?round ?ex_day ?ex_hour ?group ?host_id ?treatment ?innoculationStatus ?sample_measure ?sample_result ?pathogen_name WHERE {
?experiment a :Experiment;
:experimentDay ?ex_day;
:hasMeasurement ?measurement.
optional {?experiment :repetition ?round;}
?measurement a :Measurement;
:hasHost ?host;
:hasSample ?sample.
?host :id ?host_id;
:treatment ?treatment;
:innoculationStatus ?innoculationStatus;
:locatedIn ?env.
?env :groupNumber ?group.
optional{ ?measurement :experimentHour ?ex_hour. }
optional{ ?measurement
:hasQuantity ?quantity.
?quantity om:hasValue ?measure.
?measure om:hasNumericalValue ?sample_measure.
}
optional{ ?sample  :hasPathogen ?pathogen.
?pathogen :name ?pathogen_name }
optional {?sample :hasResult ?sample_result.}
} "
return(SPARQL(url = endpoint,query=sparql)$results)
}
#
#do data set 1
data<- get.data()
##use query to create data####
# NOT YET DONE #
endpoint <- "http://localhost:3030/dataA2/query"
get.data <- function(){
sparql <- "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
Prefix : <http://www.semanticweb.org/trans_experiment#>
Prefix om: <http://www.ontology-of-units-of-measure.org/resource/om-2/>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX tr: <http://www.thomsonreuters.com/>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
SELECT ?round ?ex_day ?ex_hour ?group ?host_id ?treatment ?innoculationStatus ?sample_measure ?sample_result ?pathogen_name WHERE {
?experiment a :Experiment;
:experimentDay ?ex_day;
:hasMeasurement ?measurement.
optional {?experiment :repetition ?round;}
?measurement a :Measurement;
:hasHost ?host;
:hasSample ?sample.
?host :id ?host_id;
:treatment ?treatment;
:innoculationStatus ?innoculationStatus;
:locatedIn ?env.
?env :groupNumber ?group.
optional{ ?measurement :experimentHour ?ex_hour. }
optional{ ?measurement
:hasQuantity ?quantity.
?quantity om:hasValue ?measure.
?measure om:hasNumericalValue ?sample_measure.
}
optional{ ?sample  :hasPathogen ?pathogen.
?pathogen :name ?pathogen_name }
optional {?sample :hasResult ?sample_result.}
} "
return(SPARQL(url = endpoint,query=sparql)$results)
}
#
#do data set 1
data<- get.data()
source("C:/Surfdrive/Projecten/SUMMERFAIR/ProjectShareSUMMERFAIR/Syntax/summer-fair/src/R/DataManipulationRules.R")
?prop.test
prop.test(c(11,6),c(18,18))
?binom.test
binom.test(c(11,6),c(18,18))
source("C:/Surfdrive/Projecten/SUMMERFAIR/ProjectShareSUMMERFAIR/Syntax/summer-fair/src/R/AlgorithmsTest.R", echo=TRUE)
head(data)
get.data <- function(){
sparql <- "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
Prefix : <http://www.semanticweb.org/trans_experiment#>
Prefix om: <http://www.ontology-of-units-of-measure.org/resource/om-2/>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX tr: <http://www.thomsonreuters.com/>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
SELECT ?round ?ex_day ?group ?host_id ?treatment ?innoculationStatus ?sample_measure ?sample_result ?pathogen_name WHERE {
?experiment a :Experiment;
:experimentDay ?ex_day;
:hasMeasurement ?measurement.
optional {?experiment :repetition ?round;}
?measurement a :Measurement;
:hasHost ?host;
:hasSample ?sample.
?host :id ?host_id;
:treatment ?treatment;
:innoculationStatus ?innoculationStatus;
:locatedIn ?env.
?env :groupNumber ?group.
optional{ ?measurement :experimentHour ?ex_hour. }
optional{ ?measurement
:hasQuantity ?quantity.
?quantity om:hasValue ?measure.
?measure om:hasNumericalValue ?sample_measure.
}
optional{ ?sample  :hasPathogen ?pathogen.
?pathogen :name ?pathogen_name }
optional {?sample :hasResult ?sample_result.}
} "
return(SPARQL(url = endpoint,query=sparql)$results)
}
#
#do data set 1
data<- get.data()
head(data)
##load pre-queried data ####
prequerydata <- read_xlsx("src/R/preprocesseddata/Sample_results.xlsx",
sheet = "maldi Swab samples")
names(usedata)
usedata$inoculationStatus
#set times to the correct resolution ####
usedata$times <- setTimes(usedata,
resolution = "day",
decimals =1)
## apply rule to determine infection states to this data set ####
datawithrule <-applyRule(usedata,   #data
rule.sinceany.recode,     #rule to apply
c("sample_result"),       #variables with output of tests
codesposneg = c("+","-","mis")) #specific parameters for this rule. Here we need to recode values containing + or - to 1, 0 or NA.
## visualize data after applying rules ####
ggplot(data = datawithrule)+
geom_raster(aes(x = times,y = host_id, fill = factor(sir)))+
facet_grid(group~.)
## visualize data after applying rules ####
ggplot(data = datawithrule)+
geom_raster(aes(x = times,y = host_id, fill = factor(sir)))
head(datawithrule)
head(data)
## apply rule to determine infection states to this data set ####
datawithrule <-applyRule(usedata,   #data
rule = rule.sinceany.cutoff,     #rule to apply
var.id = c("sample_result"),       #variables with output of tests
cutoff = 0) #specific parameters for this rule. Here we need to recode values containing + or - to 1, 0 or NA.
head(datawithrule)
## apply rule to determine infection states to this data set ####
datawithrule <-applyRule(usedata,   #data
rule = rule.sinceany.cutoff,     #rule to apply
var.id = c("sample_measure"),       #variables with output of tests
cutoff = 0) #specific parameters for this rule.
## visualize data after applying rules ####
ggplot(data = datawithrule)+
geom_raster(aes(x = times,y = host_id, fill = factor(sir)))
head(datawithrule)
debugSource("C:/Surfdrive/Projecten/SUMMERFAIR/ProjectShareSUMMERFAIR/Syntax/summer-fair/src/R/DataManipulationRules.R", echo=TRUE)
## apply rule to determine infection states to this data set ####
datawithrule <-applyRule(usedata,   #data
rule = rule.sinceany.cutoff,     #rule to apply
var.id = c("sample_measure"),       #variables with output of tests
cutoff = 0) #specific parameters for this rule.
timeseries
timeseries[,var.id]
timeseries
timeseries$sample_measure
timeseries$sample_result
timeserie
timeseries
timeseries
timeseries[,var.id]
timeseries
usedata$sample_measure
as.numeric(c("a"))
is.numeric(as.numeric(c("a")))
is.na(as.numeric(c("a")))
is.na(as.numeric(c("1")))
debugSource("C:/Surfdrive/Projecten/SUMMERFAIR/ProjectShareSUMMERFAIR/Syntax/summer-fair/src/R/DataManipulationRules.R")
debugSource("C:/Surfdrive/Projecten/SUMMERFAIR/ProjectShareSUMMERFAIR/Syntax/summer-fair/src/R/DataManipulationRules.R", echo=TRUE)
## apply rule to determine infection states to this data set ####
datawithrule <-applyRule(usedata,   #data
rule = rule.sinceany.cutoff,     #rule to apply
var.id = c("sample_measure"),       #variables with output of tests
cutoff = 0) #specific parameters for this rule.
timeseries[,var.id]
timeseries%>%
select(all_of(var.id))%>%
sapply(recodefunction)
source("C:/Surfdrive/Projecten/SUMMERFAIR/ProjectShareSUMMERFAIR/Syntax/summer-fair/src/R/DataManipulationRules.R")
source("C:/Surfdrive/Projecten/SUMMERFAIR/ProjectShareSUMMERFAIR/Syntax/summer-fair/src/R/DataManipulationRules.R", echo=TRUE)
## apply rule to determine infection states to this data set ####
datawithrule <-applyRule(usedata,   #data
rule = rule.sinceany.cutoff,     #rule to apply
var.id = c("sample_measure"),       #variables with output of tests
cutoff = 0) #specific parameters for this rule.
## visualize data after applying rules ####
ggplot(data = datawithrule)+
geom_raster(aes(x = times,y = host_id, fill = factor(sir)))
datawithrule
datawithrule%>%filter(host_id=="141")
## First specify the packages of interest -> needs to be in the docker for installation but here only library
packages = c("ggplot2",
"tidyverse",
"rje",
"readxl",
"magrittr")
## Now load or install&load all
package.check <- lapply(
packages,
FUN = function(x) {
if (!require(x, character.only = TRUE)) {
install.packages(x, dependencies = TRUE)
library(x, character.only = TRUE)
}
}
)
#Elena tests if sourcing is possible
source("src/R/DataManipulationRules.R")    #Data manipulation rules are pre- or user defined
source("src/R/LocalAlgorithm.R")           #Estimation methods
##use query to create data####
endpoint <- "http://localhost:3030/datasetA"
get.data <- function(){
sparql <- "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
Prefix : <http://www.semanticweb.org/trans_experiment#>
Prefix om: <http://www.ontology-of-units-of-measure.org/resource/om-2/>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX tr: <http://www.thomsonreuters.com/>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
SELECT ?round ?ex_day ?group ?host_id ?treatment ?innoculationStatus ?sample_measure ?sample_result ?pathogen_name WHERE {
?experiment a :Experiment;
:experimentDay ?ex_day;
:hasMeasurement ?measurement.
optional {?experiment :repetition ?round;}
?measurement a :Measurement;
:hasHost ?host;
:hasSample ?sample.
?host :id ?host_id;
:treatment ?treatment;
:innoculationStatus ?innoculationStatus;
:locatedIn ?env.
?env :groupNumber ?group.
optional{ ?measurement :experimentHour ?ex_hour. }
optional{ ?measurement
:hasQuantity ?quantity.
?quantity om:hasValue ?measure.
?measure om:hasNumericalValue ?sample_measure.
}
optional{ ?sample  :hasPathogen ?pathogen.
?pathogen :name ?pathogen_name }
optional {?sample :hasResult ?sample_result.}
} "
return(SPARQL(url = endpoint,query=sparql)$results)
}
## First specify the packages of interest -> needs to be in the docker for installation but here only library
packages = c("ggplot2",
"tidyverse",
"rje",
"readxl",
"magrittr")
## Now load or install&load all
package.check <- lapply(
packages,
FUN = function(x) {
if (!require(x, character.only = TRUE)) {
install.packages(x, dependencies = TRUE)
library(x, character.only = TRUE)
}
}
)
#Elena tests if sourcing is possible
source("src/R/DataManipulationRules.R")    #Data manipulation rules are pre- or user defined
source("src/R/LocalAlgorithm.R")           #Estimation methods
##use query to create data####
endpoint <- "http://localhost:3030/datasetA"
get.data <- function(){
sparql <- "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
Prefix : <http://www.semanticweb.org/trans_experiment#>
Prefix om: <http://www.ontology-of-units-of-measure.org/resource/om-2/>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX tr: <http://www.thomsonreuters.com/>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
SELECT ?round ?ex_day ?group ?host_id ?treatment ?innoculationStatus ?sample_measure ?sample_result ?pathogen_name WHERE {
?experiment a :Experiment;
:experimentDay ?ex_day;
:hasMeasurement ?measurement.
optional {?experiment :repetition ?round;}
?measurement a :Measurement;
:hasHost ?host;
:hasSample ?sample.
?host :id ?host_id;
:treatment ?treatment;
:innoculationStatus ?innoculationStatus;
:level1 ?level1;
:locatedIn ?env.
?env :groupNumber ?group.
optional{ ?measurement :experimentHour ?ex_hour. }
optional{ ?measurement
:hasQuantity ?quantity.
?quantity om:hasValue ?measure.
?measure om:hasNumericalValue ?sample_measure.
}
optional{ ?sample  :hasPathogen ?pathogen.
?pathogen :name ?pathogen_name }
optional {?sample :hasResult ?sample_result.}
} "
return(SPARQL(url = endpoint,query=sparql)$results)
}
#
#do data set 1
usedata<- get.data()
head(usedata)
get.data <- function(){
sparql <- "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
Prefix : <http://www.semanticweb.org/trans_experiment#>
Prefix om: <http://www.ontology-of-units-of-measure.org/resource/om-2/>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX tr: <http://www.thomsonreuters.com/>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
SELECT ?round ?ex_day ?group ?host_id ?treatment ?innoculationStatus ?sample_measure ?sample_result ?pathogen_name WHERE {
?experiment a :Experiment;
:experimentDay ?ex_day;
:hasMeasurement ?measurement.
optional {?experiment :repetition ?round;}
?measurement a :Measurement;
:hasHost ?host;
:hasSample ?sample.
?host :id ?host_id;
:treatment ?treatment;
:innoculationStatus ?innoculationStatus;
:locatedIn ?env.
?env :groupNumber ?group.
optional{ ?measurement :experimentHour ?ex_hour. }
optional{ ?measurement
:hasQuantity ?quantity.
?quantity om:hasValue ?measure.
?measure om:hasNumericalValue ?sample_measure.
}
optional{ ?sample  :hasPathogen ?pathogen.
?pathogen :name ?pathogen_name }
optional {?sample :hasResult ?sample_result.}
} "
return(SPARQL(url = endpoint,query=sparql)$results)
}
#
#do data set 1
usedata<- get.data()
head(usedata)
##use query to create data####
endpoint <- "http://localhost:3030/datasetA"
get.data <- function(){
sparql <- "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
Prefix : <http://www.semanticweb.org/trans_experiment#>
Prefix om: <http://www.ontology-of-units-of-measure.org/resource/om-2/>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX tr: <http://www.thomsonreuters.com/>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
SELECT ?round ?ex_day ?group ?host_id ?treatment ?innoculationStatus ?sample_measure ?sample_result ?pathogen_name WHERE {
?experiment a :Experiment;
:experimentDay ?ex_day;
:hasMeasurement ?measurement.
optional {?experiment :repetition ?round;}
?measurement a :Measurement;
:hasHost ?host;
:hasSample ?sample.
?host :id ?host_id;
:treatment ?treatment;
:innoculationStatus ?innoculationStatus;
:locatedIn ?env.
?env  :level1 ?level1;
:groupNumber ?group.
optional{ ?measurement :experimentHour ?ex_hour. }
optional{ ?measurement
:hasQuantity ?quantity.
?quantity om:hasValue ?measure.
?measure om:hasNumericalValue ?sample_measure.
}
optional{ ?sample  :hasPathogen ?pathogen.
?pathogen :name ?pathogen_name }
optional {?sample :hasResult ?sample_result.}
} "
return(SPARQL(url = endpoint,query=sparql)$results)
}
#
#do data set 1
usedata<- get.data()
head(usedata)
##use query to create data####
endpoint <- "http://localhost:3030/datasetA"
get.data <- function(){
sparql <- "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
Prefix : <http://www.semanticweb.org/trans_experiment#>
Prefix om: <http://www.ontology-of-units-of-measure.org/resource/om-2/>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX tr: <http://www.thomsonreuters.com/>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
SELECT ?round ?ex_day ?group ?host_id ?treatment ?innoculationStatus ?sample_measure ?sample_result ?pathogen_name WHERE {
?experiment a :Experiment;
:experimentDay ?ex_day;
:hasMeasurement ?measurement.
optional {?experiment :repetition ?round;}
?measurement a :Measurement;
:hasHost ?host;
:hasSample ?sample.
?host :id ?host_id;
:treatment ?treatment;
:innoculationStatus ?innoculationStatus;
:locatedIn ?env.
?env  :level1 ?level1;
:level2 ?level2;
:level3 ?level3;
:groupNumber ?group.
optional{ ?measurement :experimentHour ?ex_hour. }
optional{ ?measurement
:hasQuantity ?quantity.
?quantity om:hasValue ?measure.
?measure om:hasNumericalValue ?sample_measure.
}
optional{ ?sample  :hasPathogen ?pathogen.
?pathogen :name ?pathogen_name }
optional {?sample :hasResult ?sample_result.}
} "
return(SPARQL(url = endpoint,query=sparql)$results)
}
#
#do data set 1
rm(usedata);usedata<- get.data()
head(usedata)
get.data <- function(){
sparql <- "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
Prefix : <http://www.semanticweb.org/trans_experiment#>
Prefix om: <http://www.ontology-of-units-of-measure.org/resource/om-2/>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX tr: <http://www.thomsonreuters.com/>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
SELECT ?round ?ex_day ?group ?host_id ?treatment ?innoculationStatus ?sample_measure ?sample_result ?pathogen_name WHERE {
?experiment a :Experiment;
:experimentDay ?ex_day;
:hasMeasurement ?measurement.
optional {?experiment :repetition ?round;}
?measurement a :Measurement;
:hasHost ?host;
:hasSample ?sample.
?host :id ?host_id;
:treatment ?treatment;
:innoculationStatus ?innoculationStatus;
:locatedIn ?env.
?env  :groupNumber ?group.
optional{?env :level1 ?level1;
:level2 ?level2;
:level3 ?level3.}
optional{ ?measurement :experimentHour ?ex_hour. }
optional{ ?measurement
:hasQuantity ?quantity.
?quantity om:hasValue ?measure.
?measure om:hasNumericalValue ?sample_measure.
}
optional{ ?sample  :hasPathogen ?pathogen.
?pathogen :name ?pathogen_name }
optional {?sample :hasResult ?sample_result.}
} "
return(SPARQL(url = endpoint,query=sparql)$results)
}
#
#do data set 1
rm(usedata);usedata<- get.data()
head(usedata)
##arrange data for analysis ####
if(exists("data.arranged")) {rm(data.arranged)}
data.arranged <- arrangeData(data = datawithrule,
rule = rule.sinceany.recode,
var.id = c("sample_result"),
method = "glm",
codesposneg = c("+","-","mis"),
covariates = c("ex_day"))
input = data.frame(data.arranged%>%
filter(i > 0 & s>0))
#fit the input data directly
fit.real <- glm(cbind(cases, s - cases) ~ 1 ,
family = binomial(link = "cloglog"),
offset = log(i/n)*dt,
data = input)
summary(fit.real)
#fit the analyseTransmission function
fit <- analyseTransmission(data = usedata,
rule = rule.sinceany.recode,
var.id = c("sample_result"),
method = "glm",
codesposneg = c("+","-","mis"),
preventError = TRUE)
#check
fit$coefficients ==fit.real$coefficients
fit$aic == fit.real$aic
fit$residuals == fit.real$residuals
#check
fit$coefficients ==fit.real$coefficients
fit$aic == fit.real$aic
fit$residuals == fit.real$residuals
install.packages("car")
