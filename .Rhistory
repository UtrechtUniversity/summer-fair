outputlocal<- rbind(out1 = data.frame(output = "1",treat = c("A","B"),mean = c(1,2),se = c(.1,.5), n = c(100,50)),
out2 = data.frame(output = "2",treat = c("A","B"),mean = c(3,4),se = c(1.0,1.5), n = c(10,5)))
#do the meta analysis
metaout<- metagen(TE =  outputlocal$mean,
seTE = outputlocal$se,
fixed = TRUE)
#print summary
summary(metaout)
#plot forest
forest.meta(metaout)
funnel.meta(metaout)
#load output of local algorithms ####
outputlocal<- rbind(out1 = data.frame(output = "1",treat = c("A","B"),mean = c(1,2),se = c(.1,.5), n = c(100,50)),
out2 = data.frame(output = "2",treat = c("A","B"),mean = c(-3,4),se = c(1.0,1.5), n = c(10,5)))
#do the meta analysis
metaout<- metagen(TE =  outputlocal$mean,
seTE = outputlocal$se,
fixed = TRUE)
#print summary
summary(metaout)
#plot forest
forest.meta(metaout)
funnel.meta(metaout)
stderr(stud1)
#load output of local algorithms ####
stud1 <- rnorm(100, 1,.1)
stud2 <- rnorm(50, -1,.5)
stud3 <- rnorm(25, 1,.1)
stud4 <- rnorm(10, 1,.1)
std.error(stud1)
std.error<-function(v){sd(v)/sqrt(length(v))}
std.error(stud1)
outputlocal<- rbind(out1 = data.frame(output = "1",treat = c("A","B"),mean = c(mean(stud1),mean(stud2)),se = c(std.error(stud1),std.error(stud2)), n = c(length(stud1),length(stud2))),
out2 = data.frame(output = "2",treat = c("A","B"),mean = c(mean(stud3),mean(stud4)),se = c(std.error(stud3),std.error(stud4)), n = c(length(stud3),length(stud4))))
#do the meta analysis
metaout<- metagen(TE =  outputlocal$mean,
seTE = outputlocal$se,
fixed = TRUE)
#print summary
summary(metaout)
#plot forest
forest.meta(metaout)
funnel.meta(metaout)
#load output of local algorithms ####
stud1 <- rnorm(100, 1,.1)
stud2 <- rnorm(50, -1,.5)
#load output of local algorithms ####
stud1 <- rnorm(100, 1,1)
stud2 <- rnorm(50, 1,1)
stud3 <- rnorm(25, 1,1)
stud4 <- rnorm(10, 1,1)
std.error<-function(v){sd(v)/sqrt(length(v))}
outputlocal<- rbind(out1 = data.frame(output = "1",treat = c("A","B"),mean = c(mean(stud1),mean(stud2)),se = c(std.error(stud1),std.error(stud2)), n = c(length(stud1),length(stud2))),
out2 = data.frame(output = "2",treat = c("A","B"),mean = c(mean(stud3),mean(stud4)),se = c(std.error(stud3),std.error(stud4)), n = c(length(stud3),length(stud4))))
#do the meta analysis
metaout<- metagen(TE =  outputlocal$mean,
seTE = outputlocal$se,
fixed = TRUE)
#print summary
summary(metaout)
#plot forest
forest.meta(metaout)
funnel.meta(metaout)
#do the meta analysis
metaout<- metagen(TE =  outputlocal$mean,
seTE = outputlocal$se,
studlab = output,
treat = treat,
fixed = TRUE)
#print summary
summary(metaout)
#plot forest
forest.meta(metaout)
funnel.meta(metaout)
#print summary
summary(metaout)
#do the meta analysis
metaout<- metagen(TE =  outputlocal$mean,
seTE = outputlocal$se,
studlab = output,
treat = treat,
fixed = TRUE)
#do the meta analysis
metaout<- metagen(TE =  outputlocal$mean,
seTE = outputlocal$se,
studlab = output,
subgroup = treat,
fixed = TRUE)
#print summary
summary(metaout)
#plot forest
forest.meta(metaout)
funnel.meta(metaout)
#do the meta analysis
metaout<- metagen(TE =  outputlocal$mean,
seTE = outputlocal$se,
studlab = output,
subgroup = treat,
fixed = FALSE)
outputlocal<- rbind(out1 = data.frame(output = "1",treat = c("A","B"),mean = c(mean(stud1),mean(stud2)),se = c(std.error(stud1),std.error(stud2)), n = c(length(stud1),length(stud2))),
out2 = data.frame(output = "2",treat = c("A","B"),mean = c(mean(stud3),mean(stud4)),se = c(std.error(stud3),std.error(stud4)), n = c(length(stud3),length(stud4))))
#do the meta analysis
metaout<- metagen(TE =  outputlocal$mean,
seTE = outputlocal$se,
studlab = output,
subgroup = treat,
fixed = FALSE)
#do the meta analysis
metaout<- metagen(TE =  outputlocal$mean,
seTE = outputlocal$se,
studlab = outputlocal$output,
subgroup = outputlocal$treat,
fixed = FALSE)
#print summary
summary(metaout)
#load output of local algorithms ####
stud1 <- rnorm(100, 1,1)
stud2 <- rnorm(50, 1,1)
stud3 <- rnorm(5, 1,1)
stud4 <- rnorm(50, 1,1)
std.error<-function(v){sd(v)/sqrt(length(v))}
outputlocal<- rbind(out1 = data.frame(output = "1",treat = c("A","B"),mean = c(mean(stud1),mean(stud2)),se = c(std.error(stud1),std.error(stud2)), n = c(length(stud1),length(stud2))),
out2 = data.frame(output = "2",treat = c("A","B"),mean = c(mean(stud3),mean(stud4)),se = c(std.error(stud3),std.error(stud4)), n = c(length(stud3),length(stud4))))
#do the meta analysis
metaout<- metagen(TE =  outputlocal$mean,
seTE = outputlocal$se,
studlab = outputlocal$output,
subgroup = outputlocal$treat,
fixed = FALSE)
#print summary
summary(metaout)
#plot forest
forest.meta(metaout)
funnel.meta(metaout)
#load output of local algorithms ####
stud1 <- rnorm(100, 1,1)
stud2 <- rnorm(50, 1,1)
stud3 <- rnorm(-5, 1,1)
stud4 <- rnorm(50, 1,1)
std.error<-function(v){sd(v)/sqrt(length(v))}
stud3 <- rnorm(5, -1,1)
stud4 <- rnorm(50, 1,1)
std.error<-function(v){sd(v)/sqrt(length(v))}
outputlocal<- rbind(out1 = data.frame(output = "1",treat = c("A","B"),mean = c(mean(stud1),mean(stud2)),se = c(std.error(stud1),std.error(stud2)), n = c(length(stud1),length(stud2))),
out2 = data.frame(output = "2",treat = c("A","B"),mean = c(mean(stud3),mean(stud4)),se = c(std.error(stud3),std.error(stud4)), n = c(length(stud3),length(stud4))))
#do the meta analysis
metaout<- metagen(TE =  outputlocal$mean,
seTE = outputlocal$se,
studlab = outputlocal$output,
subgroup = outputlocal$treat,
fixed = FALSE)
#print summary
summary(metaout)
#plot forest
forest.meta(metaout)
funnel.meta(metaout)
funnel.meta(metaout,contour = c(0.9, 0.95, 0.99),)
funnel.meta(metaout,contour = c(0.9, 0.95, 0.99))
funnel.meta(metaout,studlab,contour = c(0.9, 0.95, 0.99))
funnel.meta(metaout,studlab=TRUE,contour = c(0.9, 0.95, 0.99))
outputlocal
#plot forest
forest.meta(metaout)
source("C:/Surfdrive/Projecten/SUMMERFAIR/ProjectShareSUMMERFAIR/Syntax/summer-fair/src/R/AlgorithmsTest.R", echo=TRUE)
#Elena tests if sourcing is possible
source("src/R/DataManipulationRules.R")    #Data manipulation rules are pre- or user defined
source("C:/Surfdrive/Projecten/SUMMERFAIR/ProjectShareSUMMERFAIR/Syntax/summer-fair/src/R/LocalAlgorithm.R", echo=TRUE)
source("C:/Surfdrive/Projecten/SUMMERFAIR/ProjectShareSUMMERFAIR/Syntax/summer-fair/src/R/LocalAlgorithm.R", echo=TRUE)
#Elena tests if sourcing is possible
source("src/R/DataManipulationRules.R")    #Data manipulation rules are pre- or user defined
source("src/R/LocalAlgorithm.R")           #Estimation methods
##create some mock data####
animals.per.group = 4; #number of S and I per group
groups = 4;
sampletimes = 10; #number of sample events
#number of observations
animals.per.group*groups*sampletimes
mockdata <- data.frame(
id = rep(c(1:(animals.per.group*groups)),each = sampletimes),         # animals
times = rep(c(1:sampletimes), (animals.per.group*groups)),           # times
location = rep(LETTERS[1:groups],
each = animals.per.group*sampletimes),     #  identify group
type = rep(c(rep("I",animals.per.group*sampletimes/2),
rep("S",animals.per.group*sampletimes/2)),groups), # first 1/2 of animals per group I
treatment = "none",                      # no treatment
sample1 = c(replicate(rbinom(sampletimes*animals.per.group/2,1,.7),
rbinom(sampletimes*animals.per.group/2,1,.3),n=groups)),               # random positive and negative samples
sample2 = c(replicate(rbinom(sampletimes*animals.per.group/2,1,.7),
rbinom(sampletimes*animals.per.group/2,1,.3),n=groups)),
sample3 = c(replicate(rbinom(sampletimes*animals.per.group/2,1,.2),
rbinom(sampletimes*animals.per.group/2,1,.1),n =groups))
)               # random positive and negative samples
##use query to create data####
# NOT YET DONE #
endpoint <- "http://localhost:3030/dataA2/query"
get.data <- function(){
sparql <- "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
Prefix : <http://www.semanticweb.org/trans_experiment#>
Prefix om: <http://www.ontology-of-units-of-measure.org/resource/om-2/>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX tr: <http://www.thomsonreuters.com/>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
SELECT ?round ?ex_day ?ex_hour ?group ?host_id ?treatment ?innoculationStatus ?sample_measure ?sample_result ?pathogen_name WHERE {
?experiment a :Experiment;
:experimentDay ?ex_day;
:hasMeasurement ?measurement.
optional {?experiment :repetition ?round;}
?measurement a :Measurement;
:hasHost ?host;
:hasSample ?sample.
?host :id ?host_id;
:treatment ?treatment;
:innoculationStatus ?innoculationStatus;
:locatedIn ?env.
?env :groupNumber ?group.
optional{ ?measurement :experimentHour ?ex_hour. }
optional{ ?measurement
:hasQuantity ?quantity.
?quantity om:hasValue ?measure.
?measure om:hasNumericalValue ?sample_measure.
}
optional{ ?sample  :hasPathogen ?pathogen.
?pathogen :name ?pathogen_name }
optional {?sample :hasResult ?sample_result.}
} "
return(SPARQL(url = endpoint,query=sparql)$results)
}
#
#do data set 1
data<- get.data()
##load pre-queried data ####
prequerydata <- read_xlsx("src/R/preprocesseddata/Sample_results.xlsx",
sheet = "maldi Swab samples")
## Set data ####
usedata <- prequerydata
## preprocess data ####
#remove redundant spaces
names(usedata)<- str_trim(names(usedata))
usedata$inoculationStatus <- str_trim(usedata$inoculationStatus)
#split group name into house and pen and name these level 1 and level 2
usedata <-usedata%>%separate(group,c("level2","level1"),"_")
#set times to the correct resolution ###
usedata$times <- setTimes(usedata,
resolution = "day",
decimals =1)
## apply rule to this data set ####
datawithrule <-applyRule(usedata,   #data
rule.sinceany.recode,     #rule to apply
c("sample_result"),       #variables with output of tests
codesposneg = c("+","-","mis")) #specific parameters for this rule. Here we need to recode values containing + or - to 1, 0 or NA.
## visualize data after applying rules ####
ggplot(data = datawithrule)+
geom_raster(aes(x = times,y = host_id, fill = factor(sir)))+
facet_grid(level1~level2)
##arrange data for analysis ####
rm(data.arranged)
data.arranged <- arrangeData(data = datawithrule,
rule = rule.sinceany.recode,
var.id = c("sample_result"),
method = "glm",
codesposneg = c("+","-","mis"),
covariates = c("ex_day"))
##arrange data for analysis ####
if(exists(data.arranged)) {rm(data.arranged)}
exists(data.arranged)
exists(af)
t <- exists(af)
t
test <- exists(af)
test
if(exists("data.arranged"))
exists("a")
exists("data.arranged")
exists("data.arrangedadfsadf")
##arrange data for analysis ####
if(exists("data.arranged")) {rm(data.arranged)}
data.arranged <- arrangeData(data = datawithrule,
rule = rule.sinceany.recode,
var.id = c("sample_result"),
method = "glm",
codesposneg = c("+","-","mis"),
covariates = c("ex_day"))
input = data.frame(data.arranged%>%
filter(i > 0 & s>0))
input
#input
fit.real <- glm(cbind(cases, s - cases) ~ 1 ,
family = binomial(link = "cloglog"),
offset = log(i/n)*dt,
data = input)
summary(fit.real)
fit <- analyseTransmission(data = usedata,
rule = rule.sinceany.recode,
var.id = c("sample_result"),
method = "glm",
codesposneg = c("+","-","mis"),
preventError = TRUE)
logLik(fit)
fit
summary(fit)
summary(fit.real)
summary(fit)
summary(fit)==summarise(fit.real)
summary(fit)==summary(fit.real)
fit$coefficients ==fit.real$coefficients
fit$coefficients ==fit.real$coefficients
aic(fit)
#check
fit$coefficients ==fit.real$coefficients
fit$aic == fit.real$aic
fit$residuals == fit.real$residuals
##use query to create data####
# NOT YET DONE #
endpoint <- "http://localhost:3030/dataA2/query"
get.data <- function(){
sparql <- "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
Prefix : <http://www.semanticweb.org/trans_experiment#>
Prefix om: <http://www.ontology-of-units-of-measure.org/resource/om-2/>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX tr: <http://www.thomsonreuters.com/>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
SELECT ?round ?ex_day ?ex_hour ?group ?host_id ?treatment ?innoculationStatus ?sample_measure ?sample_result ?pathogen_name WHERE {
?experiment a :Experiment;
:experimentDay ?ex_day;
:hasMeasurement ?measurement.
optional {?experiment :repetition ?round;}
?measurement a :Measurement;
:hasHost ?host;
:hasSample ?sample.
?host :id ?host_id;
:treatment ?treatment;
:innoculationStatus ?innoculationStatus;
:locatedIn ?env.
?env :groupNumber ?group.
optional{ ?measurement :experimentHour ?ex_hour. }
optional{ ?measurement
:hasQuantity ?quantity.
?quantity om:hasValue ?measure.
?measure om:hasNumericalValue ?sample_measure.
}
optional{ ?sample  :hasPathogen ?pathogen.
?pathogen :name ?pathogen_name }
optional {?sample :hasResult ?sample_result.}
} "
return(SPARQL(url = endpoint,query=sparql)$results)
}
#
#do data set 1
data<- get.data()
##use query to create data####
# NOT YET DONE #
endpoint <- "http://localhost:3030/dataA2/query"
get.data <- function(){
sparql <- "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
Prefix : <http://www.semanticweb.org/trans_experiment#>
Prefix om: <http://www.ontology-of-units-of-measure.org/resource/om-2/>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX tr: <http://www.thomsonreuters.com/>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
SELECT ?round ?ex_day ?ex_hour ?group ?host_id ?treatment ?innoculationStatus ?sample_measure ?sample_result ?pathogen_name WHERE {
?experiment a :Experiment;
:experimentDay ?ex_day;
:hasMeasurement ?measurement.
optional {?experiment :repetition ?round;}
?measurement a :Measurement;
:hasHost ?host;
:hasSample ?sample.
?host :id ?host_id;
:treatment ?treatment;
:innoculationStatus ?innoculationStatus;
:locatedIn ?env.
?env :groupNumber ?group.
optional{ ?measurement :experimentHour ?ex_hour. }
optional{ ?measurement
:hasQuantity ?quantity.
?quantity om:hasValue ?measure.
?measure om:hasNumericalValue ?sample_measure.
}
optional{ ?sample  :hasPathogen ?pathogen.
?pathogen :name ?pathogen_name }
optional {?sample :hasResult ?sample_result.}
} "
return(SPARQL(url = endpoint,query=sparql)$results)
}
#
#do data set 1
data<- get.data()
source("C:/Surfdrive/Projecten/SUMMERFAIR/ProjectShareSUMMERFAIR/Syntax/summer-fair/src/R/DataManipulationRules.R")
?prop.test
prop.test(c(11,6),c(18,18))
?binom.test
binom.test(c(11,6),c(18,18))
source("C:/Surfdrive/Projecten/SUMMERFAIR/ProjectShareSUMMERFAIR/Syntax/summer-fair/src/R/AlgorithmsTest.R", echo=TRUE)
head(data)
get.data <- function(){
sparql <- "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
Prefix : <http://www.semanticweb.org/trans_experiment#>
Prefix om: <http://www.ontology-of-units-of-measure.org/resource/om-2/>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX tr: <http://www.thomsonreuters.com/>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
SELECT ?round ?ex_day ?group ?host_id ?treatment ?innoculationStatus ?sample_measure ?sample_result ?pathogen_name WHERE {
?experiment a :Experiment;
:experimentDay ?ex_day;
:hasMeasurement ?measurement.
optional {?experiment :repetition ?round;}
?measurement a :Measurement;
:hasHost ?host;
:hasSample ?sample.
?host :id ?host_id;
:treatment ?treatment;
:innoculationStatus ?innoculationStatus;
:locatedIn ?env.
?env :groupNumber ?group.
optional{ ?measurement :experimentHour ?ex_hour. }
optional{ ?measurement
:hasQuantity ?quantity.
?quantity om:hasValue ?measure.
?measure om:hasNumericalValue ?sample_measure.
}
optional{ ?sample  :hasPathogen ?pathogen.
?pathogen :name ?pathogen_name }
optional {?sample :hasResult ?sample_result.}
} "
return(SPARQL(url = endpoint,query=sparql)$results)
}
#
#do data set 1
data<- get.data()
head(data)
##load pre-queried data ####
prequerydata <- read_xlsx("src/R/preprocesseddata/Sample_results.xlsx",
sheet = "maldi Swab samples")
names(usedata)
usedata$inoculationStatus
#set times to the correct resolution ####
usedata$times <- setTimes(usedata,
resolution = "day",
decimals =1)
## apply rule to determine infection states to this data set ####
datawithrule <-applyRule(usedata,   #data
rule.sinceany.recode,     #rule to apply
c("sample_result"),       #variables with output of tests
codesposneg = c("+","-","mis")) #specific parameters for this rule. Here we need to recode values containing + or - to 1, 0 or NA.
## visualize data after applying rules ####
ggplot(data = datawithrule)+
geom_raster(aes(x = times,y = host_id, fill = factor(sir)))+
facet_grid(group~.)
## visualize data after applying rules ####
ggplot(data = datawithrule)+
geom_raster(aes(x = times,y = host_id, fill = factor(sir)))
head(datawithrule)
head(data)
## apply rule to determine infection states to this data set ####
datawithrule <-applyRule(usedata,   #data
rule = rule.sinceany.cutoff,     #rule to apply
var.id = c("sample_result"),       #variables with output of tests
cutoff = 0) #specific parameters for this rule. Here we need to recode values containing + or - to 1, 0 or NA.
head(datawithrule)
## apply rule to determine infection states to this data set ####
datawithrule <-applyRule(usedata,   #data
rule = rule.sinceany.cutoff,     #rule to apply
var.id = c("sample_measure"),       #variables with output of tests
cutoff = 0) #specific parameters for this rule.
## visualize data after applying rules ####
ggplot(data = datawithrule)+
geom_raster(aes(x = times,y = host_id, fill = factor(sir)))
head(datawithrule)
debugSource("C:/Surfdrive/Projecten/SUMMERFAIR/ProjectShareSUMMERFAIR/Syntax/summer-fair/src/R/DataManipulationRules.R", echo=TRUE)
## apply rule to determine infection states to this data set ####
datawithrule <-applyRule(usedata,   #data
rule = rule.sinceany.cutoff,     #rule to apply
var.id = c("sample_measure"),       #variables with output of tests
cutoff = 0) #specific parameters for this rule.
timeseries
timeseries[,var.id]
timeseries
timeseries$sample_measure
timeseries$sample_result
timeserie
timeseries
timeseries
timeseries[,var.id]
timeseries
usedata$sample_measure
as.numeric(c("a"))
is.numeric(as.numeric(c("a")))
is.na(as.numeric(c("a")))
is.na(as.numeric(c("1")))
debugSource("C:/Surfdrive/Projecten/SUMMERFAIR/ProjectShareSUMMERFAIR/Syntax/summer-fair/src/R/DataManipulationRules.R")
debugSource("C:/Surfdrive/Projecten/SUMMERFAIR/ProjectShareSUMMERFAIR/Syntax/summer-fair/src/R/DataManipulationRules.R", echo=TRUE)
## apply rule to determine infection states to this data set ####
datawithrule <-applyRule(usedata,   #data
rule = rule.sinceany.cutoff,     #rule to apply
var.id = c("sample_measure"),       #variables with output of tests
cutoff = 0) #specific parameters for this rule.
timeseries[,var.id]
timeseries%>%
select(all_of(var.id))%>%
sapply(recodefunction)
source("C:/Surfdrive/Projecten/SUMMERFAIR/ProjectShareSUMMERFAIR/Syntax/summer-fair/src/R/DataManipulationRules.R")
source("C:/Surfdrive/Projecten/SUMMERFAIR/ProjectShareSUMMERFAIR/Syntax/summer-fair/src/R/DataManipulationRules.R", echo=TRUE)
## apply rule to determine infection states to this data set ####
datawithrule <-applyRule(usedata,   #data
rule = rule.sinceany.cutoff,     #rule to apply
var.id = c("sample_measure"),       #variables with output of tests
cutoff = 0) #specific parameters for this rule.
## visualize data after applying rules ####
ggplot(data = datawithrule)+
geom_raster(aes(x = times,y = host_id, fill = factor(sir)))
datawithrule
datawithrule%>%filter(host_id=="141")
