countdistribution.normal <- function(data){
#create a function to optimize
est.fun<- function(mu =0, sigma = 1){
#probability of uncensored data (variable censored = 0)
a <- data%>%
filter(censored == 0)%>%
select(count)%>%
dnorm(mean = mu, sd = sigma)%>%
sum
#probability of left censored data (variable censored = -1)
b <- data%>%
filter(censored == -1)%>%
select(count)%>%
pnorm(mean =  mu, sd = sigma,lower.tail = TRUE)%>%
sum
#probability of right censored data (variable censored = 1)
c <- data%>%
filter(censored == 1)%>%
select(count)%>%
pnorm(mean =  mu, sd =  sigma,lower.tail = FALSE)%>%
sum
#return the log likelihood
return(log(a+b+c))
}
#find optimal values of mu and sigma
return(mle2( est.fun, start = list(mu = 0, sigma = 1)))
}
#truncated normal distribution to get test data
rtruncnorm <- function(n, a = -Inf,b = Inf, mean =0, sd =1){
vec <- rnorm(n,mean,sd);
vec[vec<=a]<- a
vec[vec>=b]<- b
return(vec)
}
#create some test data
mu = 8; sigma =1.5;a  = 6; b = 10; n = 100;
test.data <- data.frame(
count = c(rtruncnorm(n, a,b, mu, sigma)),
censored = 0
)
test.data$censored<- as.numeric(test.data$count<= a)
test.data$censored<- as.numeric(test.data$count>= b)
#find mu and sigma
countdistribution.normal(test.data)
#find mu and sigma
countdistribution.normal(test.data)
.
mu
sigma
test.data%>%
filter(censored == 0)%>%
select(count)%>%
dnorm(mean = mu, sd = sigma)%>%
sum
test.data%>%
filter(censored == 0)%>%
select(count)
test.data%>%
filter(censored == 0)%>%
select(count)%>%sum
test.data%>%
filter(censored == 0)%>%
select(count)%>%dnorm
test.data%>%
filter(censored == 0)%>%
select(count)%>%
dnorm(mean = mu, sd = sigma)%>%
sum
dnorm(test.data%>%
filter(censored == 0)%>%
select(count)%>%
,mean = mu, sd = sigma)%>%
sum
dnorm(test.data%>%
filter(censored == 0)%>%
select(count)#%>%
,mean = mu, sd = sigma)%>%
sum
dnorm(c(1,2,3,4),mean = mu, sd = sigma)%>%
sum
dnorm(data.frame(c(1,2,3,4)),mean = mu, sd = sigma)%>%
sum
test.data%>%
filter(censored == 1)%>%
select(count)%>%as.vector%>%
pnorm(mean =  mu, sd =  sigma,lower.tail = FALSE)%>%
sum
test.data%>%
filter(censored == 1)%>%
select(count)%>%as.array%>%
pnorm(mean =  mu, sd =  sigma,lower.tail = FALSE)%>%
sum
test.data%>%
filter(censored == 1)%>%
select(count)%>%as.numeric%>%
pnorm(mean =  mu, sd =  sigma,lower.tail = FALSE)%>%
sum
test.data%>%
filter(censored == 1)%>%
select(count)%>%as.vector()
test.data%>%
filter(censored == 1)$count
test.data%>%
filter(censored == 1)%>%count
source("C:/Surfdrive/Projecten/SUMMERFAIR/ProjectShareSUMMERFAIR/Syntax/summer-fair/src/R/AlgorithmsTest.R", echo=TRUE)
source("C:/Surfdrive/Projecten/SUMMERFAIR/ProjectShareSUMMERFAIR/Syntax/summer-fair/src/R/CountDistribution.R", echo=TRUE)
library(tidyverse)
library(bbmle)
#function to estimate the normal distribution of log-transformed count data
#uses maximum likelihood estimation
countdistribution.normal <- function(data){
#create a function to optimize
est.fun<- function(mu =0, sigma = 1){
#probability of uncensored data (variable censored = 0)
a <- data%>%
filter(censored == 0)%>%
select(count)%>%
dnorm(mean = mu, sd = sigma)%>%
sum
#probability of left censored data (variable censored = -1)
b <- data%>%
filter(censored == -1)%>%
select(count)%>%
pnorm(mean =  mu, sd = sigma,lower.tail = TRUE)%>%
sum
#probability of right censored data (variable censored = 1)
c <- data%>%
filter(censored == 1)%>%
select(count)%>%
pnorm(mean =  mu, sd =  sigma,lower.tail = FALSE)%>%
sum
#return the log likelihood
return(log(a+b+c))
}
#find optimal values of mu and sigma
return(mle2( est.fun, start = list(mu = 0, sigma = 1)))
}
#truncated normal distribution to get test data
rtruncnorm <- function(n, a = -Inf,b = Inf, mean =0, sd =1){
vec <- rnorm(n,mean,sd);
vec[vec<=a]<- a
vec[vec>=b]<- b
return(vec)
}
test.data%>%
filter(censored == 1)%>%count
%>%
pnorm(mean =  mu, sd =  sigma,lower.tail = FALSE)%>%
sum
test.data%>%
filter(censored == 1)%>%count
test.data%>%
filter(censored == 1)%>%select(count)
test.data%>%
filter(censored == 1)%>%
select(count)%>%sum
test.data%>%
filter(censored == 1)%>%
select(count)%>%c
test.data%>%
filter(censored == 1)%>%
select(count)%>%
c%>%
pnorm(mean =  mu, sd =  sigma,lower.tail = FALSE)%>%
sum
test.data%>%
filter(censored == 1)%>%
select(count)%>%
c%>%
pnorm(mean =  mu, sd =  sigma,lower.tail = FALSE)
tst<- test.data%>%
filter(censored == 1)%>%
select(count)%>%
c
tst%>%
pnorm(mean =  mu, sd =  sigma,lower.tail = FALSE)%>%
sum
tst%>%pnorm(mean =  mu, sd =  sigma,lower.tail = FALSE)%>%
sum
tst%>%pnorm(mean =  mu, sd =  sigma,lower.tail = FALSE)
tst<- test.data%>%
filter(censored == 1)%>%
select(count)%>%
c%>%as.numeric
tst<- test.data%>%
filter(censored == 1)%>%
select(count)%>%
unlist
tst%>%pnorm(mean =  mu, sd =  sigma,lower.tail = FALSE)
tst%>%pnorm(mean =  mu, sd =  sigma,lower.tail = FALSE)
tst<- test.data%>%
filter(censored == 1)%>%
select(count)%>%
unlist%>%pnorm(mean =  mu, sd =  sigma,lower.tail = FALSE)
tst
tst<- test.data%>%
filter(censored == 1)%>%
select(count)%>%
unlist%>%
pnorm(mean =  mu, sd =  sigma,lower.tail = FALSE)%>% sum
tst
#function to estimate the normal distribution of log-transformed count data
#uses maximum likelihood estimation
countdistribution.normal <- function(data){
#create a function to optimize
est.fun<- function(mu =0, sigma = 1){
#probability of uncensored data (variable censored = 0)
a <- data%>%
filter(censored == 0)%>%
select(count)%>%
unlist%>%
dnorm(mean = mu, sd = sigma)%>%
sum
#probability of left censored data (variable censored = -1)
b <- data%>%
filter(censored == -1)%>%
select(count)%>%
unlist%>%
pnorm(mean =  mu, sd = sigma,lower.tail = TRUE)%>%
sum
#probability of right censored data (variable censored = 1)
c <- data%>%
filter(censored == 1)%>%
select(count)%>%
unlist%>%
pnorm(mean =  mu, sd =  sigma,lower.tail = FALSE)%>%
sum
#return the log likelihood
return(log(a+b+c))
}
#find optimal values of mu and sigma
return(mle2( est.fun, start = list(mu = 0, sigma = 1)))
}
#truncated normal distribution to get test data
rtruncnorm <- function(n, a = -Inf,b = Inf, mean =0, sd =1){
vec <- rnorm(n,mean,sd);
vec[vec<=a]<- a
vec[vec>=b]<- b
return(vec)
}
#create some test data
mu = 8; sigma =1.5;a  = 6; b = 10; n = 100;
test.data <- data.frame(
count = c(rtruncnorm(n, a,b, mu, sigma)),
censored = 0
)
test.data$censored<- as.numeric(test.data$count<= a)
test.data$censored<- as.numeric(test.data$count>= b)
dnorm(data.frame(c(1,2,3,4)),mean = mu, sd = sigma)%>%
sum
#find mu and sigma
countdistribution.normal(test.data)
warnings()
test.data
#function to estimate the normal distribution of log-transformed count data
#uses maximum likelihood estimation
countdistribution.normal <- function(data){
#create a function to optimize
est.fun<- function(mu , sigma ){
#probability of uncensored data (variable censored = 0)
a <- data%>%
filter(censored == 0)%>%
select(count)%>%
unlist%>%
dnorm(mean = mu, sd = sigma)%>%
sum
#probability of left censored data (variable censored = -1)
b <- data%>%
filter(censored == -1)%>%
select(count)%>%
unlist%>%
pnorm(mean =  mu, sd = sigma,lower.tail = TRUE)%>%
sum
#probability of right censored data (variable censored = 1)
c <- data%>%
filter(censored == 1)%>%
select(count)%>%
unlist%>%
pnorm(mean =  mu, sd =  sigma,lower.tail = FALSE)%>%
sum
#return the log likelihood
return(log(a+b+c))
}
print(est.fun(0,1))
#find optimal values of mu and sigma
return(mle2( est.fun, start = list(mu = 0, sigma = 1)))
}
#truncated normal distribution to get test data
rtruncnorm <- function(n, a = -Inf,b = Inf, mean =0, sd =1){
vec <- rnorm(n,mean,sd);
vec[vec<=a]<- a
vec[vec>=b]<- b
return(vec)
}
#create some test data
mu = 8; sigma =1.5;a  = 6; b = 10; n = 100;
test.data <- data.frame(
count = c(rtruncnorm(n, a,b, mu, sigma)),
censored = 0
)
test.data$censored<- as.numeric(test.data$count<= a)
test.data$censored<- as.numeric(test.data$count>= b)
#find mu and sigma
countdistribution.normal(test.data)
#find mu and sigma
x<- countdistribution.normal(test.data)
x
#function to estimate the normal distribution of log-transformed count data
#uses maximum likelihood estimation
countdistribution.normal <- function(data){
#create a function to optimize
est.fun<- function(mu , sigma, data){
#probability of uncensored data (variable censored = 0)
a <- data%>%
filter(censored == 0)%>%
select(count)%>%
unlist%>%
dnorm(mean = mu, sd = sigma)%>%
sum
#probability of left censored data (variable censored = -1)
b <- data%>%
filter(censored == -1)%>%
select(count)%>%
unlist%>%
pnorm(mean =  mu, sd = sigma,lower.tail = TRUE)%>%
sum
#probability of right censored data (variable censored = 1)
c <- data%>%
filter(censored == 1)%>%
select(count)%>%
unlist%>%
pnorm(mean =  mu, sd =  sigma,lower.tail = FALSE)%>%
sum
#return the log likelihood
return(log(a+b+c))
}
print(est.fun(0,1))
#find optimal values of mu and sigma
return(mle2(est.fun,
start = list(mu = 0, sigma = 1)),
fixed = list(data = data))
}
#find mu and sigma
x <- countdistribution.normal(test.data)
#function to estimate the normal distribution of log-transformed count data
#uses maximum likelihood estimation
countdistribution.normal <- function(data){
#create a function to optimize
est.fun<- function(mu , sigma){
#probability of uncensored data (variable censored = 0)
a <- data%>%
filter(censored == 0)%>%
select(count)%>%
unlist%>%
dnorm(mean = mu, sd = sigma)%>%
sum
#probability of left censored data (variable censored = -1)
b <- data%>%
filter(censored == -1)%>%
select(count)%>%
unlist%>%
pnorm(mean =  mu, sd = sigma,lower.tail = TRUE)%>%
sum
#probability of right censored data (variable censored = 1)
c <- data%>%
filter(censored == 1)%>%
select(count)%>%
unlist%>%
pnorm(mean =  mu, sd =  sigma,lower.tail = FALSE)%>%
sum
#return the log likelihood
return(log(a+b+c))
}
print(est.fun(0,1))
#find optimal values of mu and sigma
return(mle2(est.fun,
start = list(mu = 0, sigma = 1)))
}
est.fun<- function(mu , sigma){
#probability of uncensored data (variable censored = 0)
a <- data%>%
filter(censored == 0)%>%
select(count)%>%
unlist%>%
dnorm(mean = mu, sd = sigma)%>%
sum
#probability of left censored data (variable censored = -1)
b <- data%>%
filter(censored == -1)%>%
select(count)%>%
unlist%>%
pnorm(mean =  mu, sd = sigma,lower.tail = TRUE)%>%
sum
#probability of right censored data (variable censored = 1)
c <- data%>%
filter(censored == 1)%>%
select(count)%>%
unlist%>%
pnorm(mean =  mu, sd =  sigma,lower.tail = FALSE)%>%
sum
#return the log likelihood
return(log(a+b+c))
}
data = test.data
est.fun(1,1)
est.fun(1,-1)
est.fun(1,0)
#function to estimate the normal distribution of log-transformed count data
#uses maximum likelihood estimation
countdistribution.normal <- function(data){
#create a function to optimize
est.fun<- function(mu , sigma){
sigma <- abs(sigma)
#probability of uncensored data (variable censored = 0)
a <- data%>%
filter(censored == 0)%>%
select(count)%>%
unlist%>%
dnorm(mean = mu, sd = sigma)%>%
sum
#probability of left censored data (variable censored = -1)
b <- data%>%
filter(censored == -1)%>%
select(count)%>%
unlist%>%
pnorm(mean =  mu, sd = sigma,lower.tail = TRUE)%>%
sum
#probability of right censored data (variable censored = 1)
c <- data%>%
filter(censored == 1)%>%
select(count)%>%
unlist%>%
pnorm(mean =  mu, sd =  sigma,lower.tail = FALSE)%>%
sum
#return the log likelihood
return(log(a+b+c))
}
print(est.fun(0,1))
#find optimal values of mu and sigma
return(mle2(est.fun,
start = list(mu = 0, sigma = 1)))
}
#truncated normal distribution to get test data
rtruncnorm <- function(n, a = -Inf,b = Inf, mean =0, sd =1){
vec <- rnorm(n,mean,sd);
vec[vec<=a]<- a
vec[vec>=b]<- b
return(vec)
}
#create some test data
mu = 8; sigma =1.5;a  = 6; b = 10; n = 100;
test.data <- data.frame(
count = c(rtruncnorm(n, a,b, mu, sigma)),
censored = 0
)
test.data$censored<- as.numeric(test.data$count<= a)
test.data$censored<- as.numeric(test.data$count>= b)
#find mu and sigma
x <- countdistribution.normal(test.data)
x
library(bbmle)
#function to estimate the normal distribution of log-transformed count data
#uses maximum likelihood estimation
countdistribution.normal <- function(data){
#create a function to optimize
est.fun<- function(mu , sigma){
sigma <- abs(sigma)
#probability of uncensored data (variable censored = 0)
a <- data%>%
filter(censored == 0)%>%
select(count)%>%
unlist%>%
dnorm(mean = mu, sd = sigma)%>%
sum
#probability of left censored data (variable censored = -1)
b <- data%>%
filter(censored == -1)%>%
select(count)%>%
unlist%>%
pnorm(mean =  mu, sd = sigma,lower.tail = TRUE)%>%
sum
#probability of right censored data (variable censored = 1)
c <- data%>%
filter(censored == 1)%>%
select(count)%>%
unlist%>%
pnorm(mean =  mu, sd =  sigma,lower.tail = FALSE)%>%
sum
#return the log likelihood
return(log(a+b+c))
}
print(est.fun(0,1))
#find optimal values of mu and sigma
return(mle2(est.fun,
start = list(mu = 0, sigma = 1), method = "Nelder-Mead"))
}
#truncated normal distribution to get test data
rtruncnorm <- function(n, a = -Inf,b = Inf, mean =0, sd =1){
vec <- rnorm(n,mean,sd);
vec[vec<=a]<- a
vec[vec>=b]<- b
return(vec)
}
test.data <- data.frame(
count = c(rtruncnorm(n, a,b, mu, sigma)),
censored = 0
)
test.data$censored<- as.numeric(test.data$count<= a)
test.data$censored<- as.numeric(test.data$count>= b)
#find mu and sigma
x <- countdistribution.normal(test.data)
x
